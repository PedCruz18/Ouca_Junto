<!DOCTYPE html>
<html>
<head>
    <title>Transmissão de Áudio</title>
    <script src="https://cdn.jsdelivr.net/npm/socket.io-client@4.0.0/dist/socket.io.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link rel="stylesheet" href="static/css/index.css">
</head>
<body>
    <h1>Transmissão de Áudio</h1>
    <div class="file-upload-container">
        <input type="file" id="arquivoAudio" accept="audio/*" class="file-input">
        <button onclick="enviarAudio()" class="send-button">
            <i class="fas fa-paper-plane"></i>
        </button>
    </div>
    <audio id="reprodutorAudio" controls></audio>
    
    <p id="status">Status: Aguardando...</p>

    <script>
        const socket = io('http://192.168.1.32:5000');
        const buffersAudio = {};  // Armazena buffers por id_transmissao
        
        // Variáveis para controle colaborativo
        let currentStreamId = null;
        let isSyncing = false;
        let isReady = false;
        let isPlaying = false;
        const audioPlayer = document.getElementById('reprodutorAudio');
        
        function enviarAudio() {
            const entradaArquivo = document.getElementById('arquivoAudio');
            const arquivo = entradaArquivo.files[0];
            
            if (!arquivo) {
                alert("Por favor, selecione um arquivo de áudio.");
                return;
            }
            
            document.getElementById('status').innerText = "Preparando envio...";
            
            const tamanhoPedaco = 1024 * 512;  // 512KB
            const totalPedaços = Math.ceil(arquivo.size / tamanhoPedaco);
            
            // Envia metadados primeiro
            socket.emit('audio_metadata', {
                type: arquivo.type,
                totalChunks: totalPedaços
            });
            
            // Envia os pedaços
            for (let i = 0; i < totalPedaços; i++) {
                const inicio = i * tamanhoPedaco;
                const fim = Math.min(inicio + tamanhoPedaco, arquivo.size);
                const pedaco = arquivo.slice(inicio, fim);
                
                const leitor = new FileReader();
                leitor.onload = function(e) {
                    socket.emit('audio_chunk', {
                        chunkId: i,
                        data: e.target.result
                    });
                };
                leitor.readAsArrayBuffer(pedaco);
            }
        }
        
        // Recebe pedaços de áudio
        socket.on('audio_processed', function(dados) {
            currentStreamId = dados.id_transmissao; // Atualiza o ID da transmissão atual
            document.getElementById('status').innerText = 
                `Recebendo pedaço ${dados.id_pedaco + 1} de ${dados.total_pedaços}`;
            
            // Inicializa o buffer se for um novo stream
            if (!buffersAudio[dados.id_transmissao]) {
                buffersAudio[dados.id_transmissao] = {
                    pedaços: [],
                    recebidos: 0,
                    total: dados.total_pedaços
                };
            }
            
            // Armazena o pedaço recebido
            buffersAudio[dados.id_transmissao].pedaços[dados.id_pedaco] = dados.dados;
            buffersAudio[dados.id_transmissao].recebidos++;
            
            // Quando todos os pedaços forem recebidos
            if (buffersAudio[dados.id_transmissao].recebidos === dados.total_pedaços) {
                const pedaços = buffersAudio[dados.id_transmissao].pedaços;
                const blobAudio = new Blob(pedaços, { type: 'audio/*' });
                const urlAudio = URL.createObjectURL(blobAudio);
                
                audioPlayer.src = urlAudio;
                audioPlayer.onloadedmetadata = () => {
                    document.getElementById('status').innerText = "Áudio pronto - aguardando sincronização...";
                    // Notifica o servidor que está pronto para reproduzir
                    socket.emit('cliente_pronto', {
                        id_transmissao: currentStreamId
                    });
                };
                
                // Limpa o buffer após uso
                delete buffersAudio[dados.id_transmissao];
            }
        });
    
        // Recebe comando para iniciar reprodução sincronizada
        socket.on('iniciar_reproducao', function(data) {
            if (data.id_transmissao === currentStreamId) {
                isPlaying = true;
                audioPlayer.currentTime = 0;
                audioPlayer.play().catch(e => {
                    console.error("Erro ao reproduzir:", e);
                    document.getElementById('status').innerText = "Erro ao iniciar reprodução";
                });
                document.getElementById('status').innerText = "Reproduzindo sincronizado!";
            }
        });
    
        // Recebe comandos de controle (play/pause)
        socket.on('player_control', function(data) {
            try {
                if (!data || !data.action || data.id_transmissao !== currentStreamId) {
                    return;
                }
    
                // Se for um comando de play e não estivermos reproduzindo ainda
                if (data.action === 'play' && !isPlaying) {
                    return; // Ignora, pois a reprodução será iniciada pelo 'iniciar_reproducao'
                }
    
                console.log(`Recebido ${data.action} @ ${data.currentTime}s`);
                
                isSyncing = true;
                audioPlayer.currentTime = data.currentTime || 0;
                
                if (data.action === 'play' && isPlaying) {
                    audioPlayer.play().catch(e => console.error("Autoplay bloqueado:", e));
                } else {
                    audioPlayer.pause();
                }
                
                document.getElementById('status').innerText = 
                    `Controle: ${data.action} @ ${data.currentTime.toFixed(2)}s`;
                
            } catch (e) {
                console.error("Erro no handler de controle:", e);
            } finally {
                setTimeout(() => isSyncing = false, 100);
            }
        });
    
        // Envia comandos quando usuário interage
        function sendControl(action) {
            if (isSyncing || !currentStreamId || !isPlaying) return;
            
            socket.emit('player_control', {
                action: action,
                currentTime: audioPlayer.currentTime,
                id_transmissao: currentStreamId
            });
            
            console.log(`Enviando ${action} @ ${audioPlayer.currentTime}s`);
        }
    
        // Configura listeners de eventos
        audioPlayer.addEventListener('play', () => sendControl('play'));
        audioPlayer.addEventListener('pause', () => sendControl('pause'));
        audioPlayer.addEventListener('seeked', () => {
            if (!audioPlayer.paused) {
                sendControl('play');
            }
        });
    
        // Status da conexão
        socket.on('connect', () => {
            document.getElementById('status').innerText = "Conectado ao servidor";
        });
        
        socket.on('disconnect', () => {
            document.getElementById('status').innerText = "Desconectado do servidor";
        });
    </script>
</body>
</html>